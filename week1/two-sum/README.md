# 1. Two Sum

## 📋 문제 설명

정수 배열 `nums`와 정수 `target`이 주어질 때, 합이 `target`이 되는 두 수의 인덱스를 반환하세요.

각 입력에 대해 정확히 하나의 해답이 존재한다고 가정할 수 있으며, 같은 요소를 두 번 사용할 수 없습니다.

답은 어떤 순서로든 반환할 수 있습니다.

### 예제

**예제 1:**
```
입력: nums = [2,7,11,15], target = 9
출력: [0,1]
설명: nums[0] + nums[1] == 9이므로 [0,1]을 반환합니다.
```

**예제 2:**
```
입력: nums = [3,2,4], target = 6
출력: [1,2]
```

**예제 3:**
```
입력: nums = [3,3], target = 6
출력: [0,1]
```

### 제약 조건
- `2 ≤ nums.length ≤ 10⁴`
- `-10⁹ ≤ nums[i] ≤ 10⁹`
- `-10⁹ ≤ target ≤ 10⁹`
- **정확히 하나의 유효한 답이 존재합니다.**

## 💡 접근 방법

### 방법 1: 브루트 포스 (Brute Force)
- 모든 가능한 두 수의 조합을 확인
- 시간 복잡도: O(n²)
- 공간 복잡도: O(1)

### 방법 2: 해시 테이블 (Hash Table) ⭐
- 한 번의 순회로 해결
- 각 원소에 대해 complement (target - 현재 값)를 해시 테이블에서 찾기
- 시간 복잡도: O(n)
- 공간 복잡도: O(n)

## 🔍 핵심 아이디어

1. **Complement 활용**: `target - nums[i]`가 이미 방문한 요소 중에 있는지 확인
2. **해시 테이블**: 빠른 조회를 위해 값과 인덱스를 저장
3. **One-pass**: 한 번의 순회로 해결 가능

## 📊 복잡도 분석

| 방법 | 시간 복잡도 | 공간 복잡도 | 설명 |
|------|------------|------------|------|
| 브루트 포스 | O(n²) | O(1) | 모든 조합 확인 |
| 해시 테이블 | O(n) | O(n) | 한 번 순회 + 해시 저장 |

## 🎯 최적 해법 단계

1. **해시 맵 생성**: 숫자와 인덱스를 저장할 맵 준비
2. **배열 순회**: 각 요소에 대해
   - complement = target - 현재 값 계산
   - complement가 맵에 있는지 확인
   - 있다면 → 답 반환
   - 없다면 → 현재 값과 인덱스를 맵에 저장
3. **결과 반환**: 찾은 두 인덱스 반환

## 💻 구현

- [Java 구현](./Solution.java)
- [Kotlin 구현](./Solution.kt)

## 🧪 테스트 케이스

```java
// 기본 케이스
nums = [2,7,11,15], target = 9 → [0,1]

// 같은 값이 있는 경우
nums = [3,3], target = 6 → [0,1]

// 음수가 포함된 경우
nums = [-1,-2,-3,-4,-5], target = -8 → [2,4]

// 큰 수의 경우
nums = [1000000000,2000000000], target = 3000000000 → [0,1]
```

## 🔗 관련 문제

- [167. Two Sum II - Input Array Is Sorted](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/)
- [15. 3Sum](https://leetcode.com/problems/3sum/)
- [18. 4Sum](https://leetcode.com/problems/4sum/)
- [454. 4Sum II](https://leetcode.com/problems/4sum-ii/)

## 📚 학습 포인트

1. **해시 테이블의 활용**: O(1) 조회 시간을 활용한 최적화
2. **Trade-off**: 시간 복잡도를 줄이기 위해 공간 복잡도 증가
3. **패턴 인식**: "두 수의 합" 문제의 기본 패턴
4. **Edge Case 처리**: 같은 값, 음수, 큰 수 등의 경우

## 🔍 주의사항

- 같은 인덱스를 두 번 사용하지 않도록 주의
- 해시 맵에 저장하기 전에 complement 확인
- 정수 오버플로우 가능성 (하지만 문제 제약상 괜찮음)

---

**난이도**: Easy  
**카테고리**: Array, Hash Table  
**LeetCode 링크**: https://leetcode.com/problems/two-sum/